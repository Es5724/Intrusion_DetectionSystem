# -*- coding: utf-8 -*-

"""
AI 기반 취약점 우선순위 분석기 (AI-based Vulnerability Priority Analyzer)

취약점 스캔 결과를 RF 위협 확률과 CVE 데이터베이스를 통합하여
실제 위험도를 평가하고 우선순위를 결정합니다.

핵심 기능:
- RF 모델 위협 확률 통합
- CVE 심각도 점수 반영
- 실시간 위협 컨텍스트 고려
- 우선순위 점수 계산 (0-100)
- 조치 권장사항 생성
"""

import logging
import numpy as np
from typing import Dict, List, Tuple, Optional
from datetime import datetime, timedelta
from collections import defaultdict
import json

logger = logging.getLogger('VulnerabilityPriorityAnalyzer')


class CVEDatabase:
    """
    CVE (Common Vulnerabilities and Exposures) 데이터베이스 시뮬레이터
    
    실제 프로덕션 환경에서는 NVD (National Vulnerability Database) API를 사용
    """
    
    def __init__(self):
        """CVE 데이터베이스 초기화"""
        # 포트/서비스별 대표 CVE 목록 (샘플)
        self.port_cve_map = {
            # RDP (Remote Desktop Protocol)
            3389: [
                {'cve_id': 'CVE-2019-0708', 'cvss_score': 9.8, 'severity': 'CRITICAL',
                 'description': 'BlueKeep - 원격 코드 실행 취약점',
                 'exploit_available': True, 'published_date': '2019-05-14'},
                {'cve_id': 'CVE-2020-0609', 'cvss_score': 9.8, 'severity': 'CRITICAL',
                 'description': 'RDP Gateway 원격 코드 실행 취약점',
                 'exploit_available': True, 'published_date': '2020-01-14'}
            ],
            
            # SMB (Server Message Block)
            445: [
                {'cve_id': 'CVE-2017-0144', 'cvss_score': 9.3, 'severity': 'CRITICAL',
                 'description': 'EternalBlue - WannaCry 랜섬웨어 취약점',
                 'exploit_available': True, 'published_date': '2017-03-14'},
                {'cve_id': 'CVE-2020-0796', 'cvss_score': 10.0, 'severity': 'CRITICAL',
                 'description': 'SMBGhost - 원격 코드 실행 취약점',
                 'exploit_available': True, 'published_date': '2020-03-10'}
            ],
            
            # SSH
            22: [
                {'cve_id': 'CVE-2018-15473', 'cvss_score': 5.3, 'severity': 'MEDIUM',
                 'description': 'OpenSSH 사용자 열거 취약점',
                 'exploit_available': True, 'published_date': '2018-08-15'}
            ],
            
            # Telnet
            23: [
                {'cve_id': 'CVE-2020-8163', 'cvss_score': 9.8, 'severity': 'CRITICAL',
                 'description': 'Telnet 원격 코드 실행 취약점',
                 'exploit_available': True, 'published_date': '2020-06-19'}
            ],
            
            # MySQL
            3306: [
                {'cve_id': 'CVE-2019-2729', 'cvss_score': 9.8, 'severity': 'CRITICAL',
                 'description': 'MySQL Server 원격 코드 실행',
                 'exploit_available': False, 'published_date': '2019-07-16'}
            ],
            
            # PostgreSQL
            5432: [
                {'cve_id': 'CVE-2019-10130', 'cvss_score': 7.5, 'severity': 'HIGH',
                 'description': 'PostgreSQL 권한 상승 취약점',
                 'exploit_available': False, 'published_date': '2019-05-09'}
            ],
            
            # HTTP/HTTPS
            80: [
                {'cve_id': 'CVE-2021-44228', 'cvss_score': 10.0, 'severity': 'CRITICAL',
                 'description': 'Log4Shell - Apache Log4j 원격 코드 실행',
                 'exploit_available': True, 'published_date': '2021-12-10'}
            ],
            443: [
                {'cve_id': 'CVE-2014-0160', 'cvss_score': 7.5, 'severity': 'HIGH',
                 'description': 'Heartbleed - OpenSSL 정보 노출',
                 'exploit_available': True, 'published_date': '2014-04-07'}
            ]
        }
        
        logger.info("CVE 데이터베이스 초기화 완료")
    
    def get_cve_info(self, port: int) -> List[Dict]:
        """
        포트에 해당하는 CVE 정보 조회
        
        Args:
            port: 포트 번호
        
        Returns:
            CVE 정보 리스트
        """
        return self.port_cve_map.get(port, [])
    
    def calculate_cve_risk(self, port: int) -> Tuple[float, int, bool]:
        """
        포트의 CVE 위험도 계산
        
        Args:
            port: 포트 번호
        
        Returns:
            (평균 CVSS 점수, CVE 개수, 익스플로잇 존재 여부)
        """
        cve_list = self.get_cve_info(port)
        
        if not cve_list:
            return 0.0, 0, False
        
        avg_cvss = np.mean([cve['cvss_score'] for cve in cve_list])
        cve_count = len(cve_list)
        has_exploit = any(cve['exploit_available'] for cve in cve_list)
        
        return avg_cvss, cve_count, has_exploit


class VulnerabilityPriorityAnalyzer:
    """
    AI 기반 취약점 우선순위 분석기
    
    RF 위협 확률 + CVE 심각도 + 실시간 컨텍스트를 통합하여
    취약점의 실제 위험도와 우선순위를 결정합니다.
    """
    
    def __init__(self, threat_model=None):
        """
        Args:
            threat_model: RF 위협 탐지 모델 (옵션)
        """
        self.threat_model = threat_model
        self.cve_database = CVEDatabase()
        
        # 위협 이력 추적
        self.threat_history = defaultdict(list)
        
        # 우선순위 가중치 설정
        self.weights = {
            'rf_probability': 0.35,      # RF 위협 확률 (35%)
            'cvss_score': 0.30,          # CVE CVSS 점수 (30%)
            'exploit_available': 0.15,   # 익스플로잇 존재 (15%)
            'threat_frequency': 0.10,    # 위협 빈도 (10%)
            'service_importance': 0.10   # 서비스 중요도 (10%)
        }
        
        logger.info("AI 기반 취약점 우선순위 분석기 초기화 완료")
    
    def analyze_vulnerability(self, 
                             vulnerability_info: Dict,
                             rf_threat_probability: Optional[float] = None,
                             service_context: Optional[Dict] = None) -> Dict:
        """
        단일 취약점 분석 및 우선순위 결정
        
        Args:
            vulnerability_info: 취약점 정보
                - port: 포트 번호
                - service: 서비스 이름
                - risk_level: 기본 위험도
            rf_threat_probability: RF 모델의 위협 확률 (0-1)
            service_context: 서비스 컨텍스트 정보
        
        Returns:
            분석 결과 딕셔너리
        """
        if service_context is None:
            service_context = {}
        
        port = vulnerability_info.get('port', 0)
        service = vulnerability_info.get('service', 'Unknown')
        host_ip = vulnerability_info.get('host_ip', 'unknown')
        
        logger.debug(f"취약점 분석 시작: {host_ip}:{port} ({service})")
        
        # ========== 1. RF 위협 확률 ==========
        if rf_threat_probability is None:
            # RF 모델이 있으면 실행
            if self.threat_model is not None:
                try:
                    rf_threat_probability = self._predict_threat_probability(
                        vulnerability_info
                    )
                except:
                    rf_threat_probability = 0.5  # 기본값
            else:
                rf_threat_probability = 0.5
        
        rf_score = rf_threat_probability * 100  # 0-100 스케일
        
        # ========== 2. CVE 위험도 ==========
        cvss_score, cve_count, has_exploit = self.cve_database.calculate_cve_risk(port)
        
        # CVSS 점수 정규화 (0-10 → 0-100)
        cvss_normalized = (cvss_score / 10.0) * 100
        
        # ========== 3. 익스플로잇 가용성 ==========
        exploit_score = 100 if has_exploit else 30
        
        # ========== 4. 위협 빈도 ==========
        frequency_score = self._calculate_threat_frequency(host_ip, port)
        
        # ========== 5. 서비스 중요도 ==========
        importance_score = self._calculate_service_importance(
            port, service, service_context
        )
        
        # ========== 우선순위 점수 계산 (가중 평균) ==========
        priority_score = (
            rf_score * self.weights['rf_probability'] +
            cvss_normalized * self.weights['cvss_score'] +
            exploit_score * self.weights['exploit_available'] +
            frequency_score * self.weights['threat_frequency'] +
            importance_score * self.weights['service_importance']
        )
        
        # ========== 우선순위 등급 결정 ==========
        if priority_score >= 80:
            priority_level = 'CRITICAL'
            action_urgency = '즉시 조치 필요'
        elif priority_score >= 60:
            priority_level = 'HIGH'
            action_urgency = '24시간 내 조치'
        elif priority_score >= 40:
            priority_level = 'MEDIUM'
            action_urgency = '1주일 내 조치'
        else:
            priority_level = 'LOW'
            action_urgency = '정기 점검 시 조치'
        
        # ========== CVE 정보 조회 ==========
        cve_info = self.cve_database.get_cve_info(port)
        
        # ========== 조치 권장사항 생성 ==========
        recommendations = self._generate_recommendations(
            port, service, priority_level, has_exploit, cve_info
        )
        
        # ========== 결과 구성 ==========
        analysis_result = {
            'host_ip': host_ip,
            'port': port,
            'service': service,
            'priority_score': round(priority_score, 2),
            'priority_level': priority_level,
            'action_urgency': action_urgency,
            
            # 상세 점수
            'detailed_scores': {
                'rf_threat_probability': round(rf_threat_probability, 3),
                'rf_score': round(rf_score, 2),
                'cvss_score': round(cvss_score, 2),
                'cvss_normalized': round(cvss_normalized, 2),
                'exploit_score': exploit_score,
                'frequency_score': round(frequency_score, 2),
                'importance_score': round(importance_score, 2)
            },
            
            # CVE 정보
            'cve_count': cve_count,
            'has_exploit': has_exploit,
            'cve_details': cve_info[:3] if cve_info else [],  # 상위 3개만
            
            # 조치 사항
            'recommendations': recommendations,
            
            # 메타데이터
            'analysis_time': datetime.now().isoformat(),
            'analyzer_version': '1.0'
        }
        
        logger.info(f"취약점 분석 완료: {host_ip}:{port} - 우선순위 {priority_level} ({priority_score:.1f}점)")
        
        # 이력 업데이트
        self._update_threat_history(host_ip, port, rf_threat_probability)
        
        return analysis_result
    
    def analyze_multiple_vulnerabilities(self, 
                                        vulnerabilities: List[Dict],
                                        rf_probabilities: Optional[List[float]] = None) -> List[Dict]:
        """
        여러 취약점 일괄 분석 및 우선순위 정렬
        
        Args:
            vulnerabilities: 취약점 목록
            rf_probabilities: RF 위협 확률 목록 (옵션)
        
        Returns:
            우선순위 순으로 정렬된 분석 결과 리스트
        """
        logger.info(f"{len(vulnerabilities)}개 취약점 일괄 분석 시작")
        
        if rf_probabilities is None:
            rf_probabilities = [None] * len(vulnerabilities)
        
        results = []
        for vuln, rf_prob in zip(vulnerabilities, rf_probabilities):
            analysis = self.analyze_vulnerability(vuln, rf_prob)
            results.append(analysis)
        
        # 우선순위 점수 기준 내림차순 정렬
        results.sort(key=lambda x: x['priority_score'], reverse=True)
        
        logger.info(f"일괄 분석 완료: CRITICAL={sum(1 for r in results if r['priority_level']=='CRITICAL')}, "
                   f"HIGH={sum(1 for r in results if r['priority_level']=='HIGH')}")
        
        return results
    
    def _predict_threat_probability(self, vulnerability_info: Dict) -> float:
        """
        RF 모델을 사용한 위협 확률 예측
        
        Args:
            vulnerability_info: 취약점 정보
        
        Returns:
            위협 확률 (0-1)
        """
        # TODO: 실제 RF 모델 통합
        # 현재는 포트 기반 휴리스틱 사용
        port = vulnerability_info.get('port', 0)
        
        high_risk_ports = {4444, 31337, 1337, 23, 445}
        medium_risk_ports = {3389, 21, 3306, 5432}
        
        if port in high_risk_ports:
            return 0.85
        elif port in medium_risk_ports:
            return 0.65
        else:
            return 0.35
    
    def _calculate_threat_frequency(self, host_ip: str, port: int) -> float:
        """
        위협 빈도 계산 (과거 30일간)
        
        Returns:
            빈도 점수 (0-100)
        """
        key = f"{host_ip}:{port}"
        history = self.threat_history.get(key, [])
        
        if not history:
            return 10.0  # 기본 점수
        
        # 30일 이내 위협 횟수
        cutoff_date = datetime.now() - timedelta(days=30)
        recent_threats = [
            prob for timestamp, prob in history 
            if timestamp > cutoff_date and prob > 0.5
        ]
        
        # 빈도 기반 점수 (최대 100)
        frequency_count = len(recent_threats)
        frequency_score = min(frequency_count * 10, 100)
        
        return frequency_score
    
    def _calculate_service_importance(self, port: int, service: str, 
                                      context: Dict) -> float:
        """
        서비스 중요도 계산
        
        Returns:
            중요도 점수 (0-100)
        """
        # 컨텍스트에서 제공된 중요도 우선
        if 'importance' in context:
            return context['importance'] * 100
        
        # 포트 기반 중요도 매핑
        critical_services = {
            80: 90,   # HTTP (웹)
            443: 90,  # HTTPS (웹)
            22: 80,   # SSH (관리)
            3389: 80, # RDP (관리)
            3306: 85, # MySQL (DB)
            5432: 85, # PostgreSQL (DB)
            53: 70,   # DNS
            25: 65,   # SMTP (메일)
        }
        
        return critical_services.get(port, 50)  # 기본 50점
    
    def _generate_recommendations(self, port: int, service: str, 
                                  priority_level: str, has_exploit: bool,
                                  cve_info: List[Dict]) -> List[str]:
        """
        조치 권장사항 생성
        
        Returns:
            권장사항 리스트
        """
        recommendations = []
        
        # 우선순위 기반 권장사항
        if priority_level == 'CRITICAL':
            recommendations.append("🔴 [긴급] 즉시 해당 포트 차단 또는 서비스 중지")
            recommendations.append("🔴 [긴급] 시스템 전체 보안 점검 수행")
            
            if has_exploit:
                recommendations.append("🔴 [긴급] 공개된 익스플로잇 존재 - 패치 즉시 적용")
        
        elif priority_level == 'HIGH':
            recommendations.append("🟠 [높음] 24시간 내 보안 패치 적용")
            recommendations.append("🟠 [높음] 방화벽 규칙 강화 및 접근 제한")
        
        elif priority_level == 'MEDIUM':
            recommendations.append("🟡 [중간] 1주일 내 보안 업데이트 계획 수립")
            recommendations.append("🟡 [중간] 모니터링 강화 및 로그 분석")
        
        else:
            recommendations.append("🟢 [낮음] 정기 점검 시 업데이트 고려")
        
        # 서비스별 구체적 권장사항
        service_recommendations = {
            'SSH': ['키 기반 인증 사용', '포트 변경 고려', 'Fail2ban 설정'],
            'RDP': ['NLA(Network Level Authentication) 활성화', 'VPN 사용 권장', '강력한 패스워드 정책'],
            'MySQL': ['외부 접근 차단', 'bind-address 127.0.0.1 설정', '최신 버전 업데이트'],
            'HTTP': ['HTTPS 전환', '보안 헤더 설정', 'WAF 적용 고려'],
            'Telnet': ['즉시 비활성화', 'SSH로 전환'],
            'SMB': ['SMBv1 비활성화', '최신 패치 적용', '불필요시 차단']
        }
        
        if service in service_recommendations:
            for rec in service_recommendations[service]:
                recommendations.append(f"  - {rec}")
        
        # CVE 기반 권장사항
        if cve_info:
            top_cve = max(cve_info, key=lambda x: x['cvss_score'])
            recommendations.append(f"💡 참고: {top_cve['cve_id']} 관련 패치 확인 필요")
        
        return recommendations
    
    def _update_threat_history(self, host_ip: str, port: int, probability: float):
        """위협 이력 업데이트"""
        key = f"{host_ip}:{port}"
        self.threat_history[key].append((datetime.now(), probability))
        
        # 이력 크기 제한 (최근 100개)
        if len(self.threat_history[key]) > 100:
            self.threat_history[key] = self.threat_history[key][-100:]
    
    def generate_priority_report(self, analysis_results: List[Dict]) -> str:
        """
        우선순위 보고서 생성 (텍스트 형식)
        
        Args:
            analysis_results: 분석 결과 리스트
        
        Returns:
            포맷된 보고서 문자열
        """
        report = []
        report.append("=" * 80)
        report.append("          AI 기반 취약점 우선순위 분석 보고서")
        report.append("=" * 80)
        report.append(f"생성 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"분석 대상: {len(analysis_results)}개 취약점")
        report.append("")
        
        # 우선순위별 통계
        priority_counts = defaultdict(int)
        for result in analysis_results:
            priority_counts[result['priority_level']] += 1
        
        report.append("[ 우선순위별 통계 ]")
        report.append(f"  🔴 CRITICAL: {priority_counts['CRITICAL']}개")
        report.append(f"  🟠 HIGH:     {priority_counts['HIGH']}개")
        report.append(f"  🟡 MEDIUM:   {priority_counts['MEDIUM']}개")
        report.append(f"  🟢 LOW:      {priority_counts['LOW']}개")
        report.append("")
        
        # 상위 10개 취약점
        report.append("[ 최우선 조치 대상 (상위 10개) ]")
        report.append("")
        
        for i, result in enumerate(analysis_results[:10], 1):
            report.append(f"{i}. {result['priority_level']} - 우선순위 점수: {result['priority_score']:.1f}")
            report.append(f"   호스트: {result['host_ip']}:{result['port']} ({result['service']})")
            report.append(f"   조치 기한: {result['action_urgency']}")
            
            if result['cve_count'] > 0:
                report.append(f"   관련 CVE: {result['cve_count']}개")
            
            if result['recommendations']:
                report.append(f"   권장사항:")
                for rec in result['recommendations'][:2]:  # 상위 2개만
                    report.append(f"     {rec}")
            
            report.append("")
        
        return "\n".join(report)


# 전역 싱글톤 인스턴스
_global_analyzer = None


def get_priority_analyzer(threat_model=None) -> VulnerabilityPriorityAnalyzer:
    """
    전역 우선순위 분석기 인스턴스 반환 (싱글톤 패턴)
    
    Args:
        threat_model: RF 위협 탐지 모델 (옵션)
    
    Returns:
        VulnerabilityPriorityAnalyzer 인스턴스
    """
    global _global_analyzer
    if _global_analyzer is None:
        _global_analyzer = VulnerabilityPriorityAnalyzer(threat_model=threat_model)
    return _global_analyzer

