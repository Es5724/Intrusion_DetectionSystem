# -*- coding: utf-8 -*-

"""
AI ê¸°ë°˜ ì·¨ì•½ì  ìš°ì„ ìˆœìœ„ ë¶„ì„ê¸° (AI-based Vulnerability Priority Analyzer)

ì·¨ì•½ì  ìŠ¤ìº” ê²°ê³¼ë¥¼ RF ìœ„í˜‘ í™•ë¥ ê³¼ CVE ë°ì´í„°ë² ì´ìŠ¤ë¥¼ í†µí•©í•˜ì—¬
ì‹¤ì œ ìœ„í—˜ë„ë¥¼ í‰ê°€í•˜ê³  ìš°ì„ ìˆœìœ„ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.

í•µì‹¬ ê¸°ëŠ¥:
- RF ëª¨ë¸ ìœ„í˜‘ í™•ë¥  í†µí•©
- CVE ì‹¬ê°ë„ ì ìˆ˜ ë°˜ì˜
- ì‹¤ì‹œê°„ ìœ„í˜‘ ì»¨í…ìŠ¤íŠ¸ ê³ ë ¤
- ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚° (0-100)
- ì¡°ì¹˜ ê¶Œì¥ì‚¬í•­ ìƒì„±
"""

import logging
import numpy as np
from typing import Dict, List, Tuple, Optional
from datetime import datetime, timedelta
from collections import defaultdict
import json

logger = logging.getLogger('VulnerabilityPriorityAnalyzer')


class CVEDatabase:
    """
    CVE (Common Vulnerabilities and Exposures) ë°ì´í„°ë² ì´ìŠ¤ ì‹œë®¬ë ˆì´í„°
    
    ì‹¤ì œ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œëŠ” NVD (National Vulnerability Database) APIë¥¼ ì‚¬ìš©
    """
    
    def __init__(self):
        """CVE ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”"""
        # í¬íŠ¸/ì„œë¹„ìŠ¤ë³„ ëŒ€í‘œ CVE ëª©ë¡ (ìƒ˜í”Œ)
        self.port_cve_map = {
            # RDP (Remote Desktop Protocol)
            3389: [
                {'cve_id': 'CVE-2019-0708', 'cvss_score': 9.8, 'severity': 'CRITICAL',
                 'description': 'BlueKeep - ì›ê²© ì½”ë“œ ì‹¤í–‰ ì·¨ì•½ì ',
                 'exploit_available': True, 'published_date': '2019-05-14'},
                {'cve_id': 'CVE-2020-0609', 'cvss_score': 9.8, 'severity': 'CRITICAL',
                 'description': 'RDP Gateway ì›ê²© ì½”ë“œ ì‹¤í–‰ ì·¨ì•½ì ',
                 'exploit_available': True, 'published_date': '2020-01-14'}
            ],
            
            # SMB (Server Message Block)
            445: [
                {'cve_id': 'CVE-2017-0144', 'cvss_score': 9.3, 'severity': 'CRITICAL',
                 'description': 'EternalBlue - WannaCry ëœì„¬ì›¨ì–´ ì·¨ì•½ì ',
                 'exploit_available': True, 'published_date': '2017-03-14'},
                {'cve_id': 'CVE-2020-0796', 'cvss_score': 10.0, 'severity': 'CRITICAL',
                 'description': 'SMBGhost - ì›ê²© ì½”ë“œ ì‹¤í–‰ ì·¨ì•½ì ',
                 'exploit_available': True, 'published_date': '2020-03-10'}
            ],
            
            # SSH
            22: [
                {'cve_id': 'CVE-2018-15473', 'cvss_score': 5.3, 'severity': 'MEDIUM',
                 'description': 'OpenSSH ì‚¬ìš©ì ì—´ê±° ì·¨ì•½ì ',
                 'exploit_available': True, 'published_date': '2018-08-15'}
            ],
            
            # Telnet
            23: [
                {'cve_id': 'CVE-2020-8163', 'cvss_score': 9.8, 'severity': 'CRITICAL',
                 'description': 'Telnet ì›ê²© ì½”ë“œ ì‹¤í–‰ ì·¨ì•½ì ',
                 'exploit_available': True, 'published_date': '2020-06-19'}
            ],
            
            # MySQL
            3306: [
                {'cve_id': 'CVE-2019-2729', 'cvss_score': 9.8, 'severity': 'CRITICAL',
                 'description': 'MySQL Server ì›ê²© ì½”ë“œ ì‹¤í–‰',
                 'exploit_available': False, 'published_date': '2019-07-16'}
            ],
            
            # PostgreSQL
            5432: [
                {'cve_id': 'CVE-2019-10130', 'cvss_score': 7.5, 'severity': 'HIGH',
                 'description': 'PostgreSQL ê¶Œí•œ ìƒìŠ¹ ì·¨ì•½ì ',
                 'exploit_available': False, 'published_date': '2019-05-09'}
            ],
            
            # HTTP/HTTPS
            80: [
                {'cve_id': 'CVE-2021-44228', 'cvss_score': 10.0, 'severity': 'CRITICAL',
                 'description': 'Log4Shell - Apache Log4j ì›ê²© ì½”ë“œ ì‹¤í–‰',
                 'exploit_available': True, 'published_date': '2021-12-10'}
            ],
            443: [
                {'cve_id': 'CVE-2014-0160', 'cvss_score': 7.5, 'severity': 'HIGH',
                 'description': 'Heartbleed - OpenSSL ì •ë³´ ë…¸ì¶œ',
                 'exploit_available': True, 'published_date': '2014-04-07'}
            ]
        }
        
        logger.info("CVE ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì™„ë£Œ")
    
    def get_cve_info(self, port: int) -> List[Dict]:
        """
        í¬íŠ¸ì— í•´ë‹¹í•˜ëŠ” CVE ì •ë³´ ì¡°íšŒ
        
        Args:
            port: í¬íŠ¸ ë²ˆí˜¸
        
        Returns:
            CVE ì •ë³´ ë¦¬ìŠ¤íŠ¸
        """
        return self.port_cve_map.get(port, [])
    
    def calculate_cve_risk(self, port: int) -> Tuple[float, int, bool]:
        """
        í¬íŠ¸ì˜ CVE ìœ„í—˜ë„ ê³„ì‚°
        
        Args:
            port: í¬íŠ¸ ë²ˆí˜¸
        
        Returns:
            (í‰ê·  CVSS ì ìˆ˜, CVE ê°œìˆ˜, ìµìŠ¤í”Œë¡œì‡ ì¡´ì¬ ì—¬ë¶€)
        """
        cve_list = self.get_cve_info(port)
        
        if not cve_list:
            return 0.0, 0, False
        
        avg_cvss = np.mean([cve['cvss_score'] for cve in cve_list])
        cve_count = len(cve_list)
        has_exploit = any(cve['exploit_available'] for cve in cve_list)
        
        return avg_cvss, cve_count, has_exploit


class VulnerabilityPriorityAnalyzer:
    """
    AI ê¸°ë°˜ ì·¨ì•½ì  ìš°ì„ ìˆœìœ„ ë¶„ì„ê¸°
    
    RF ìœ„í˜‘ í™•ë¥  + CVE ì‹¬ê°ë„ + ì‹¤ì‹œê°„ ì»¨í…ìŠ¤íŠ¸ë¥¼ í†µí•©í•˜ì—¬
    ì·¨ì•½ì ì˜ ì‹¤ì œ ìœ„í—˜ë„ì™€ ìš°ì„ ìˆœìœ„ë¥¼ ê²°ì •í•©ë‹ˆë‹¤.
    """
    
    def __init__(self, threat_model=None):
        """
        Args:
            threat_model: RF ìœ„í˜‘ íƒì§€ ëª¨ë¸ (ì˜µì…˜)
        """
        self.threat_model = threat_model
        self.cve_database = CVEDatabase()
        
        # ìœ„í˜‘ ì´ë ¥ ì¶”ì 
        self.threat_history = defaultdict(list)
        
        # ìš°ì„ ìˆœìœ„ ê°€ì¤‘ì¹˜ ì„¤ì •
        self.weights = {
            'rf_probability': 0.35,      # RF ìœ„í˜‘ í™•ë¥  (35%)
            'cvss_score': 0.30,          # CVE CVSS ì ìˆ˜ (30%)
            'exploit_available': 0.15,   # ìµìŠ¤í”Œë¡œì‡ ì¡´ì¬ (15%)
            'threat_frequency': 0.10,    # ìœ„í˜‘ ë¹ˆë„ (10%)
            'service_importance': 0.10   # ì„œë¹„ìŠ¤ ì¤‘ìš”ë„ (10%)
        }
        
        logger.info("AI ê¸°ë°˜ ì·¨ì•½ì  ìš°ì„ ìˆœìœ„ ë¶„ì„ê¸° ì´ˆê¸°í™” ì™„ë£Œ")
    
    def analyze_vulnerability(self, 
                             vulnerability_info: Dict,
                             rf_threat_probability: Optional[float] = None,
                             service_context: Optional[Dict] = None) -> Dict:
        """
        ë‹¨ì¼ ì·¨ì•½ì  ë¶„ì„ ë° ìš°ì„ ìˆœìœ„ ê²°ì •
        
        Args:
            vulnerability_info: ì·¨ì•½ì  ì •ë³´
                - port: í¬íŠ¸ ë²ˆí˜¸
                - service: ì„œë¹„ìŠ¤ ì´ë¦„
                - risk_level: ê¸°ë³¸ ìœ„í—˜ë„
            rf_threat_probability: RF ëª¨ë¸ì˜ ìœ„í˜‘ í™•ë¥  (0-1)
            service_context: ì„œë¹„ìŠ¤ ì»¨í…ìŠ¤íŠ¸ ì •ë³´
        
        Returns:
            ë¶„ì„ ê²°ê³¼ ë”•ì…”ë„ˆë¦¬
        """
        if service_context is None:
            service_context = {}
        
        port = vulnerability_info.get('port', 0)
        service = vulnerability_info.get('service', 'Unknown')
        host_ip = vulnerability_info.get('host_ip', 'unknown')
        
        logger.debug(f"ì·¨ì•½ì  ë¶„ì„ ì‹œì‘: {host_ip}:{port} ({service})")
        
        # ========== 1. RF ìœ„í˜‘ í™•ë¥  ==========
        if rf_threat_probability is None:
            # RF ëª¨ë¸ì´ ìˆìœ¼ë©´ ì‹¤í–‰
            if self.threat_model is not None:
                try:
                    rf_threat_probability = self._predict_threat_probability(
                        vulnerability_info
                    )
                except:
                    rf_threat_probability = 0.5  # ê¸°ë³¸ê°’
            else:
                rf_threat_probability = 0.5
        
        rf_score = rf_threat_probability * 100  # 0-100 ìŠ¤ì¼€ì¼
        
        # ========== 2. CVE ìœ„í—˜ë„ ==========
        cvss_score, cve_count, has_exploit = self.cve_database.calculate_cve_risk(port)
        
        # CVSS ì ìˆ˜ ì •ê·œí™” (0-10 â†’ 0-100)
        cvss_normalized = (cvss_score / 10.0) * 100
        
        # ========== 3. ìµìŠ¤í”Œë¡œì‡ ê°€ìš©ì„± ==========
        exploit_score = 100 if has_exploit else 30
        
        # ========== 4. ìœ„í˜‘ ë¹ˆë„ ==========
        frequency_score = self._calculate_threat_frequency(host_ip, port)
        
        # ========== 5. ì„œë¹„ìŠ¤ ì¤‘ìš”ë„ ==========
        importance_score = self._calculate_service_importance(
            port, service, service_context
        )
        
        # ========== ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚° (ê°€ì¤‘ í‰ê· ) ==========
        priority_score = (
            rf_score * self.weights['rf_probability'] +
            cvss_normalized * self.weights['cvss_score'] +
            exploit_score * self.weights['exploit_available'] +
            frequency_score * self.weights['threat_frequency'] +
            importance_score * self.weights['service_importance']
        )
        
        # ========== ìš°ì„ ìˆœìœ„ ë“±ê¸‰ ê²°ì • ==========
        if priority_score >= 80:
            priority_level = 'CRITICAL'
            action_urgency = 'ì¦‰ì‹œ ì¡°ì¹˜ í•„ìš”'
        elif priority_score >= 60:
            priority_level = 'HIGH'
            action_urgency = '24ì‹œê°„ ë‚´ ì¡°ì¹˜'
        elif priority_score >= 40:
            priority_level = 'MEDIUM'
            action_urgency = '1ì£¼ì¼ ë‚´ ì¡°ì¹˜'
        else:
            priority_level = 'LOW'
            action_urgency = 'ì •ê¸° ì ê²€ ì‹œ ì¡°ì¹˜'
        
        # ========== CVE ì •ë³´ ì¡°íšŒ ==========
        cve_info = self.cve_database.get_cve_info(port)
        
        # ========== ì¡°ì¹˜ ê¶Œì¥ì‚¬í•­ ìƒì„± ==========
        recommendations = self._generate_recommendations(
            port, service, priority_level, has_exploit, cve_info
        )
        
        # ========== ê²°ê³¼ êµ¬ì„± ==========
        analysis_result = {
            'host_ip': host_ip,
            'port': port,
            'service': service,
            'priority_score': round(priority_score, 2),
            'priority_level': priority_level,
            'action_urgency': action_urgency,
            
            # ìƒì„¸ ì ìˆ˜
            'detailed_scores': {
                'rf_threat_probability': round(rf_threat_probability, 3),
                'rf_score': round(rf_score, 2),
                'cvss_score': round(cvss_score, 2),
                'cvss_normalized': round(cvss_normalized, 2),
                'exploit_score': exploit_score,
                'frequency_score': round(frequency_score, 2),
                'importance_score': round(importance_score, 2)
            },
            
            # CVE ì •ë³´
            'cve_count': cve_count,
            'has_exploit': has_exploit,
            'cve_details': cve_info[:3] if cve_info else [],  # ìƒìœ„ 3ê°œë§Œ
            
            # ì¡°ì¹˜ ì‚¬í•­
            'recommendations': recommendations,
            
            # ë©”íƒ€ë°ì´í„°
            'analysis_time': datetime.now().isoformat(),
            'analyzer_version': '1.0'
        }
        
        logger.info(f"ì·¨ì•½ì  ë¶„ì„ ì™„ë£Œ: {host_ip}:{port} - ìš°ì„ ìˆœìœ„ {priority_level} ({priority_score:.1f}ì )")
        
        # ì´ë ¥ ì—…ë°ì´íŠ¸
        self._update_threat_history(host_ip, port, rf_threat_probability)
        
        return analysis_result
    
    def analyze_multiple_vulnerabilities(self, 
                                        vulnerabilities: List[Dict],
                                        rf_probabilities: Optional[List[float]] = None) -> List[Dict]:
        """
        ì—¬ëŸ¬ ì·¨ì•½ì  ì¼ê´„ ë¶„ì„ ë° ìš°ì„ ìˆœìœ„ ì •ë ¬
        
        Args:
            vulnerabilities: ì·¨ì•½ì  ëª©ë¡
            rf_probabilities: RF ìœ„í˜‘ í™•ë¥  ëª©ë¡ (ì˜µì…˜)
        
        Returns:
            ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬ëœ ë¶„ì„ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸
        """
        logger.info(f"{len(vulnerabilities)}ê°œ ì·¨ì•½ì  ì¼ê´„ ë¶„ì„ ì‹œì‘")
        
        if rf_probabilities is None:
            rf_probabilities = [None] * len(vulnerabilities)
        
        results = []
        for vuln, rf_prob in zip(vulnerabilities, rf_probabilities):
            analysis = self.analyze_vulnerability(vuln, rf_prob)
            results.append(analysis)
        
        # ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê¸°ì¤€ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
        results.sort(key=lambda x: x['priority_score'], reverse=True)
        
        logger.info(f"ì¼ê´„ ë¶„ì„ ì™„ë£Œ: CRITICAL={sum(1 for r in results if r['priority_level']=='CRITICAL')}, "
                   f"HIGH={sum(1 for r in results if r['priority_level']=='HIGH')}")
        
        return results
    
    def _predict_threat_probability(self, vulnerability_info: Dict) -> float:
        """
        RF ëª¨ë¸ì„ ì‚¬ìš©í•œ ìœ„í˜‘ í™•ë¥  ì˜ˆì¸¡
        
        Args:
            vulnerability_info: ì·¨ì•½ì  ì •ë³´
        
        Returns:
            ìœ„í˜‘ í™•ë¥  (0-1)
        """
        # TODO: ì‹¤ì œ RF ëª¨ë¸ í†µí•©
        # í˜„ì¬ëŠ” í¬íŠ¸ ê¸°ë°˜ íœ´ë¦¬ìŠ¤í‹± ì‚¬ìš©
        port = vulnerability_info.get('port', 0)
        
        high_risk_ports = {4444, 31337, 1337, 23, 445}
        medium_risk_ports = {3389, 21, 3306, 5432}
        
        if port in high_risk_ports:
            return 0.85
        elif port in medium_risk_ports:
            return 0.65
        else:
            return 0.35
    
    def _calculate_threat_frequency(self, host_ip: str, port: int) -> float:
        """
        ìœ„í˜‘ ë¹ˆë„ ê³„ì‚° (ê³¼ê±° 30ì¼ê°„)
        
        Returns:
            ë¹ˆë„ ì ìˆ˜ (0-100)
        """
        key = f"{host_ip}:{port}"
        history = self.threat_history.get(key, [])
        
        if not history:
            return 10.0  # ê¸°ë³¸ ì ìˆ˜
        
        # 30ì¼ ì´ë‚´ ìœ„í˜‘ íšŸìˆ˜
        cutoff_date = datetime.now() - timedelta(days=30)
        recent_threats = [
            prob for timestamp, prob in history 
            if timestamp > cutoff_date and prob > 0.5
        ]
        
        # ë¹ˆë„ ê¸°ë°˜ ì ìˆ˜ (ìµœëŒ€ 100)
        frequency_count = len(recent_threats)
        frequency_score = min(frequency_count * 10, 100)
        
        return frequency_score
    
    def _calculate_service_importance(self, port: int, service: str, 
                                      context: Dict) -> float:
        """
        ì„œë¹„ìŠ¤ ì¤‘ìš”ë„ ê³„ì‚°
        
        Returns:
            ì¤‘ìš”ë„ ì ìˆ˜ (0-100)
        """
        # ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì œê³µëœ ì¤‘ìš”ë„ ìš°ì„ 
        if 'importance' in context:
            return context['importance'] * 100
        
        # í¬íŠ¸ ê¸°ë°˜ ì¤‘ìš”ë„ ë§¤í•‘
        critical_services = {
            80: 90,   # HTTP (ì›¹)
            443: 90,  # HTTPS (ì›¹)
            22: 80,   # SSH (ê´€ë¦¬)
            3389: 80, # RDP (ê´€ë¦¬)
            3306: 85, # MySQL (DB)
            5432: 85, # PostgreSQL (DB)
            53: 70,   # DNS
            25: 65,   # SMTP (ë©”ì¼)
        }
        
        return critical_services.get(port, 50)  # ê¸°ë³¸ 50ì 
    
    def _generate_recommendations(self, port: int, service: str, 
                                  priority_level: str, has_exploit: bool,
                                  cve_info: List[Dict]) -> List[str]:
        """
        ì¡°ì¹˜ ê¶Œì¥ì‚¬í•­ ìƒì„±
        
        Returns:
            ê¶Œì¥ì‚¬í•­ ë¦¬ìŠ¤íŠ¸
        """
        recommendations = []
        
        # ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ê¶Œì¥ì‚¬í•­
        if priority_level == 'CRITICAL':
            recommendations.append("ğŸ”´ [ê¸´ê¸‰] ì¦‰ì‹œ í•´ë‹¹ í¬íŠ¸ ì°¨ë‹¨ ë˜ëŠ” ì„œë¹„ìŠ¤ ì¤‘ì§€")
            recommendations.append("ğŸ”´ [ê¸´ê¸‰] ì‹œìŠ¤í…œ ì „ì²´ ë³´ì•ˆ ì ê²€ ìˆ˜í–‰")
            
            if has_exploit:
                recommendations.append("ğŸ”´ [ê¸´ê¸‰] ê³µê°œëœ ìµìŠ¤í”Œë¡œì‡ ì¡´ì¬ - íŒ¨ì¹˜ ì¦‰ì‹œ ì ìš©")
        
        elif priority_level == 'HIGH':
            recommendations.append("ğŸŸ  [ë†’ìŒ] 24ì‹œê°„ ë‚´ ë³´ì•ˆ íŒ¨ì¹˜ ì ìš©")
            recommendations.append("ğŸŸ  [ë†’ìŒ] ë°©í™”ë²½ ê·œì¹™ ê°•í™” ë° ì ‘ê·¼ ì œí•œ")
        
        elif priority_level == 'MEDIUM':
            recommendations.append("ğŸŸ¡ [ì¤‘ê°„] 1ì£¼ì¼ ë‚´ ë³´ì•ˆ ì—…ë°ì´íŠ¸ ê³„íš ìˆ˜ë¦½")
            recommendations.append("ğŸŸ¡ [ì¤‘ê°„] ëª¨ë‹ˆí„°ë§ ê°•í™” ë° ë¡œê·¸ ë¶„ì„")
        
        else:
            recommendations.append("ğŸŸ¢ [ë‚®ìŒ] ì •ê¸° ì ê²€ ì‹œ ì—…ë°ì´íŠ¸ ê³ ë ¤")
        
        # ì„œë¹„ìŠ¤ë³„ êµ¬ì²´ì  ê¶Œì¥ì‚¬í•­
        service_recommendations = {
            'SSH': ['í‚¤ ê¸°ë°˜ ì¸ì¦ ì‚¬ìš©', 'í¬íŠ¸ ë³€ê²½ ê³ ë ¤', 'Fail2ban ì„¤ì •'],
            'RDP': ['NLA(Network Level Authentication) í™œì„±í™”', 'VPN ì‚¬ìš© ê¶Œì¥', 'ê°•ë ¥í•œ íŒ¨ìŠ¤ì›Œë“œ ì •ì±…'],
            'MySQL': ['ì™¸ë¶€ ì ‘ê·¼ ì°¨ë‹¨', 'bind-address 127.0.0.1 ì„¤ì •', 'ìµœì‹  ë²„ì „ ì—…ë°ì´íŠ¸'],
            'HTTP': ['HTTPS ì „í™˜', 'ë³´ì•ˆ í—¤ë” ì„¤ì •', 'WAF ì ìš© ê³ ë ¤'],
            'Telnet': ['ì¦‰ì‹œ ë¹„í™œì„±í™”', 'SSHë¡œ ì „í™˜'],
            'SMB': ['SMBv1 ë¹„í™œì„±í™”', 'ìµœì‹  íŒ¨ì¹˜ ì ìš©', 'ë¶ˆí•„ìš”ì‹œ ì°¨ë‹¨']
        }
        
        if service in service_recommendations:
            for rec in service_recommendations[service]:
                recommendations.append(f"  - {rec}")
        
        # CVE ê¸°ë°˜ ê¶Œì¥ì‚¬í•­
        if cve_info:
            top_cve = max(cve_info, key=lambda x: x['cvss_score'])
            recommendations.append(f"ğŸ’¡ ì°¸ê³ : {top_cve['cve_id']} ê´€ë ¨ íŒ¨ì¹˜ í™•ì¸ í•„ìš”")
        
        return recommendations
    
    def _update_threat_history(self, host_ip: str, port: int, probability: float):
        """ìœ„í˜‘ ì´ë ¥ ì—…ë°ì´íŠ¸"""
        key = f"{host_ip}:{port}"
        self.threat_history[key].append((datetime.now(), probability))
        
        # ì´ë ¥ í¬ê¸° ì œí•œ (ìµœê·¼ 100ê°œ)
        if len(self.threat_history[key]) > 100:
            self.threat_history[key] = self.threat_history[key][-100:]
    
    def generate_priority_report(self, analysis_results: List[Dict]) -> str:
        """
        ìš°ì„ ìˆœìœ„ ë³´ê³ ì„œ ìƒì„± (í…ìŠ¤íŠ¸ í˜•ì‹)
        
        Args:
            analysis_results: ë¶„ì„ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸
        
        Returns:
            í¬ë§·ëœ ë³´ê³ ì„œ ë¬¸ìì—´
        """
        report = []
        report.append("=" * 80)
        report.append("          AI ê¸°ë°˜ ì·¨ì•½ì  ìš°ì„ ìˆœìœ„ ë¶„ì„ ë³´ê³ ì„œ")
        report.append("=" * 80)
        report.append(f"ìƒì„± ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"ë¶„ì„ ëŒ€ìƒ: {len(analysis_results)}ê°œ ì·¨ì•½ì ")
        report.append("")
        
        # ìš°ì„ ìˆœìœ„ë³„ í†µê³„
        priority_counts = defaultdict(int)
        for result in analysis_results:
            priority_counts[result['priority_level']] += 1
        
        report.append("[ ìš°ì„ ìˆœìœ„ë³„ í†µê³„ ]")
        report.append(f"  ğŸ”´ CRITICAL: {priority_counts['CRITICAL']}ê°œ")
        report.append(f"  ğŸŸ  HIGH:     {priority_counts['HIGH']}ê°œ")
        report.append(f"  ğŸŸ¡ MEDIUM:   {priority_counts['MEDIUM']}ê°œ")
        report.append(f"  ğŸŸ¢ LOW:      {priority_counts['LOW']}ê°œ")
        report.append("")
        
        # ìƒìœ„ 10ê°œ ì·¨ì•½ì 
        report.append("[ ìµœìš°ì„  ì¡°ì¹˜ ëŒ€ìƒ (ìƒìœ„ 10ê°œ) ]")
        report.append("")
        
        for i, result in enumerate(analysis_results[:10], 1):
            report.append(f"{i}. {result['priority_level']} - ìš°ì„ ìˆœìœ„ ì ìˆ˜: {result['priority_score']:.1f}")
            report.append(f"   í˜¸ìŠ¤íŠ¸: {result['host_ip']}:{result['port']} ({result['service']})")
            report.append(f"   ì¡°ì¹˜ ê¸°í•œ: {result['action_urgency']}")
            
            if result['cve_count'] > 0:
                report.append(f"   ê´€ë ¨ CVE: {result['cve_count']}ê°œ")
            
            if result['recommendations']:
                report.append(f"   ê¶Œì¥ì‚¬í•­:")
                for rec in result['recommendations'][:2]:  # ìƒìœ„ 2ê°œë§Œ
                    report.append(f"     {rec}")
            
            report.append("")
        
        return "\n".join(report)


# ì „ì—­ ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
_global_analyzer = None


def get_priority_analyzer(threat_model=None) -> VulnerabilityPriorityAnalyzer:
    """
    ì „ì—­ ìš°ì„ ìˆœìœ„ ë¶„ì„ê¸° ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜ (ì‹±ê¸€í†¤ íŒ¨í„´)
    
    Args:
        threat_model: RF ìœ„í˜‘ íƒì§€ ëª¨ë¸ (ì˜µì…˜)
    
    Returns:
        VulnerabilityPriorityAnalyzer ì¸ìŠ¤í„´ìŠ¤
    """
    global _global_analyzer
    if _global_analyzer is None:
        _global_analyzer = VulnerabilityPriorityAnalyzer(threat_model=threat_model)
    return _global_analyzer

