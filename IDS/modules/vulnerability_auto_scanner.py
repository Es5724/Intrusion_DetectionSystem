# -*- coding: utf-8 -*-

"""
자동 취약점 스캐너 스케줄러 (Automated Vulnerability Scanner Scheduler)

주기적으로 네트워크 내 호스트를 자동 스캔하여 취약점을 탐지합니다.

핵심 기능:
- 1시간 주기 전체 네트워크 자동 스캔
- 10분 주기 의심 호스트 재스캔
- 스캔 결과 자동 저장 및 알림
- 스캔 부하 관리 (시스템 리소스 고려)
"""

import socket
import threading
import time
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Set, Optional, Tuple
from collections import defaultdict
import json
import os

# 포트 스캔 관련 임포트
try:
    from .port_scan_detector import VulnerabilityScanner
except ImportError:
    from port_scan_detector import VulnerabilityScanner

logger = logging.getLogger('VulnerabilityAutoScanner')


class NetworkDiscovery:
    """
    네트워크 호스트 발견 시스템
    """
    
    def __init__(self, network_range: str = "192.168.0.0/24"):
        """
        Args:
            network_range: 스캔할 네트워크 범위 (CIDR 표기법)
        """
        self.network_range = network_range
        self.discovered_hosts = set()
        self.last_discovery_time = None
        
        logger.info(f"네트워크 발견 시스템 초기화: {network_range}")
    
    def discover_hosts(self, timeout: float = 0.5) -> Set[str]:
        """
        네트워크 내 활성 호스트 발견
        
        Args:
            timeout: 연결 타임아웃 (초)
        
        Returns:
            발견된 호스트 IP 세트
        """
        discovered = set()
        
        # CIDR 파싱
        network_base, cidr = self._parse_network_range()
        
        logger.info(f"호스트 발견 시작: {self.network_range}")
        
        # 간단한 ping 스캔 (실제로는 TCP SYN을 사용)
        for i in range(1, min(255, 2 ** (32 - cidr))):
            ip = f"{network_base}.{i}"
            
            # 일반적인 포트로 연결 시도 (80, 443, 22)
            for port in [80, 443, 22, 3389]:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(timeout)
                    result = sock.connect_ex((ip, port))
                    sock.close()
                    
                    if result == 0:
                        discovered.add(ip)
                        logger.debug(f"호스트 발견: {ip} (포트 {port} 열림)")
                        break
                except Exception as e:
                    logger.debug(f"호스트 {ip} 스캔 오류: {e}")
                    continue
        
        self.discovered_hosts = discovered
        self.last_discovery_time = datetime.now()
        
        logger.info(f"호스트 발견 완료: {len(discovered)}개 호스트")
        return discovered
    
    def _parse_network_range(self) -> Tuple[str, int]:
        """
        CIDR 표기법 파싱
        
        Returns:
            (네트워크 베이스, CIDR 비트)
        """
        if '/' in self.network_range:
            network_base, cidr_str = self.network_range.split('/')
            cidr = int(cidr_str)
            # 마지막 옥텟 제거
            network_base = '.'.join(network_base.split('.')[:-1])
        else:
            # CIDR 없으면 /24 가정
            network_base = '.'.join(self.network_range.split('.')[:-1])
            cidr = 24
        
        return network_base, cidr


class PortScanner:
    """
    포트 스캔 실행 엔진
    """
    
    def __init__(self, timeout: float = 1.0):
        """
        Args:
            timeout: 포트 연결 타임아웃 (초)
        """
        self.timeout = timeout
        
        # 기본 스캔 포트 (자주 사용되는 포트)
        self.default_ports = [
            21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 
            1433, 1521, 3306, 3389, 5432, 5900, 8080, 8443
        ]
        
        # 확장 스캔 포트 (상세 스캔용)
        self.extended_ports = list(range(1, 1025))  # well-known ports
        
        logger.info("포트 스캐너 초기화 완료")
    
    def scan_host(self, target_ip: str, ports: Optional[List[int]] = None, 
                  extended: bool = False) -> List[int]:
        """
        대상 호스트의 열린 포트 스캔
        
        Args:
            target_ip: 대상 IP 주소
            ports: 스캔할 포트 목록 (None이면 기본 포트)
            extended: 확장 스캔 여부
        
        Returns:
            열린 포트 목록
        """
        if ports is None:
            ports = self.extended_ports if extended else self.default_ports
        
        open_ports = []
        
        logger.debug(f"{target_ip} 스캔 시작: {len(ports)}개 포트")
        
        for port in ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.timeout)
                result = sock.connect_ex((target_ip, port))
                sock.close()
                
                if result == 0:
                    open_ports.append(port)
                    logger.debug(f"{target_ip}:{port} 열림")
            except Exception as e:
                logger.debug(f"{target_ip}:{port} 스캔 오류: {e}")
                continue
        
        logger.info(f"{target_ip} 스캔 완료: {len(open_ports)}개 열린 포트")
        return open_ports


class VulnerabilityAutoScanner:
    """
    자동 취약점 스캐너 스케줄러
    
    주기적으로 네트워크를 스캔하고 취약점을 자동으로 탐지합니다.
    """
    
    def __init__(self, 
                 network_range: str = "192.168.0.0/24",
                 full_scan_interval: int = 3600,  # 1시간
                 quick_scan_interval: int = 600,  # 10분
                 output_dir: str = "scan_results"):
        """
        Args:
            network_range: 스캔할 네트워크 범위
            full_scan_interval: 전체 스캔 주기 (초)
            quick_scan_interval: 빠른 스캔 주기 (초)
            output_dir: 스캔 결과 저장 디렉토리
        """
        self.network_range = network_range
        self.full_scan_interval = full_scan_interval
        self.quick_scan_interval = quick_scan_interval
        self.output_dir = output_dir
        
        # 컴포넌트 초기화
        self.network_discovery = NetworkDiscovery(network_range)
        self.port_scanner = PortScanner()
        self.vulnerability_scanner = VulnerabilityScanner()
        
        # 스캔 결과 저장
        self.scan_history = []
        self.suspicious_hosts = set()  # 의심스러운 호스트 추적
        
        # 스레드 제어
        self.running = False
        self.full_scan_thread = None
        self.quick_scan_thread = None
        
        # 통계
        self.stats = {
            'total_scans': 0,
            'total_hosts_scanned': 0,
            'total_vulnerabilities_found': 0,
            'last_full_scan': None,
            'last_quick_scan': None
        }
        
        # 출력 디렉토리 생성
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        logger.info(f"자동 취약점 스캐너 초기화 완료: {network_range}")
        logger.info(f"전체 스캔 주기: {full_scan_interval}초, 빠른 스캔 주기: {quick_scan_interval}초")
    
    def start(self):
        """스캐너 시작"""
        if self.running:
            logger.warning("스캐너가 이미 실행 중입니다")
            return
        
        self.running = True
        
        # 전체 스캔 스레드 시작
        self.full_scan_thread = threading.Thread(
            target=self._full_scan_worker,
            daemon=True,
            name="FullScanThread"
        )
        self.full_scan_thread.start()
        
        # 빠른 스캔 스레드 시작
        self.quick_scan_thread = threading.Thread(
            target=self._quick_scan_worker,
            daemon=True,
            name="QuickScanThread"
        )
        self.quick_scan_thread.start()
        
        logger.info("자동 취약점 스캐너 시작됨")
    
    def stop(self):
        """스캐너 중지"""
        if not self.running:
            logger.warning("스캐너가 실행 중이 아닙니다")
            return
        
        self.running = False
        
        # 스레드 종료 대기
        if self.full_scan_thread:
            self.full_scan_thread.join(timeout=5)
        if self.quick_scan_thread:
            self.quick_scan_thread.join(timeout=5)
        
        logger.info("자동 취약점 스캐너 중지됨")
    
    def _full_scan_worker(self):
        """전체 스캔 워커 스레드"""
        logger.info("전체 스캔 스레드 시작")
        
        # 즉시 첫 스캔 실행
        self._perform_full_scan()
        
        while self.running:
            try:
                # 다음 스캔까지 대기
                time.sleep(self.full_scan_interval)
                
                if not self.running:
                    break
                
                # 전체 스캔 실행
                self._perform_full_scan()
                
            except Exception as e:
                logger.error(f"전체 스캔 워커 오류: {e}")
                time.sleep(60)  # 오류 시 1분 대기
        
        logger.info("전체 스캔 스레드 종료")
    
    def _quick_scan_worker(self):
        """빠른 스캔 워커 스레드 (의심 호스트 재스캔)"""
        logger.info("빠른 스캔 스레드 시작")
        
        # 첫 스캔은 5분 후 시작
        time.sleep(300)
        
        while self.running:
            try:
                # 의심 호스트가 있으면 재스캔
                if self.suspicious_hosts:
                    self._perform_quick_scan()
                else:
                    logger.debug("의심 호스트 없음 - 빠른 스캔 스킵")
                
                # 다음 스캔까지 대기
                time.sleep(self.quick_scan_interval)
                
            except Exception as e:
                logger.error(f"빠른 스캔 워커 오류: {e}")
                time.sleep(60)
        
        logger.info("빠른 스캔 스레드 종료")
    
    def _perform_full_scan(self):
        """전체 네트워크 스캔 수행"""
        scan_start_time = datetime.now()
        logger.info(f"=== 전체 네트워크 스캔 시작: {scan_start_time.strftime('%Y-%m-%d %H:%M:%S')} ===")
        
        try:
            # 1. 호스트 발견
            logger.info("1단계: 호스트 발견")
            discovered_hosts = self.network_discovery.discover_hosts()
            
            if not discovered_hosts:
                logger.warning("발견된 호스트가 없습니다")
                return
            
            # 2. 각 호스트 포트 스캔
            logger.info(f"2단계: 포트 스캔 ({len(discovered_hosts)}개 호스트)")
            scan_results = []
            
            for host_ip in discovered_hosts:
                logger.info(f"호스트 스캔 중: {host_ip}")
                
                # 포트 스캔
                open_ports = self.port_scanner.scan_host(host_ip, extended=False)
                
                if not open_ports:
                    logger.debug(f"{host_ip}: 열린 포트 없음")
                    continue
                
                # 3. 취약점 분석
                vulnerability_analysis = self.vulnerability_scanner.analyze_open_ports(
                    open_ports, host_ip
                )
                
                scan_results.append(vulnerability_analysis)
                
                # 위험도가 높으면 의심 호스트로 추가
                if vulnerability_analysis['overall_risk'] in ['critical', 'high']:
                    self.suspicious_hosts.add(host_ip)
                    logger.warning(f"의심 호스트 발견: {host_ip} (위험도: {vulnerability_analysis['overall_risk']})")
            
            # 4. 스캔 결과 저장
            scan_summary = {
                'scan_type': 'full_scan',
                'scan_time': scan_start_time.isoformat(),
                'duration_seconds': (datetime.now() - scan_start_time).total_seconds(),
                'hosts_scanned': len(discovered_hosts),
                'hosts_with_vulnerabilities': len(scan_results),
                'results': scan_results
            }
            
            self._save_scan_results(scan_summary)
            
            # 5. 통계 업데이트
            self.stats['total_scans'] += 1
            self.stats['total_hosts_scanned'] += len(discovered_hosts)
            self.stats['total_vulnerabilities_found'] += sum(
                len(r['vulnerabilities']) for r in scan_results
            )
            self.stats['last_full_scan'] = scan_start_time.isoformat()
            
            logger.info(f"=== 전체 스캔 완료: {len(scan_results)}개 취약점 발견 ===")
            
        except Exception as e:
            logger.error(f"전체 스캔 중 오류: {e}")
    
    def _perform_quick_scan(self):
        """의심 호스트 빠른 재스캔"""
        scan_start_time = datetime.now()
        logger.info(f"=== 빠른 스캔 시작: {len(self.suspicious_hosts)}개 의심 호스트 ===")
        
        try:
            scan_results = []
            hosts_to_remove = set()
            
            for host_ip in list(self.suspicious_hosts):
                logger.info(f"의심 호스트 재스캔: {host_ip}")
                
                # 포트 스캔 (확장 모드)
                open_ports = self.port_scanner.scan_host(host_ip, extended=True)
                
                if not open_ports:
                    # 더 이상 열린 포트가 없으면 의심 목록에서 제거
                    hosts_to_remove.add(host_ip)
                    logger.info(f"{host_ip}: 열린 포트 없음 - 의심 목록에서 제거")
                    continue
                
                # 취약점 분석
                vulnerability_analysis = self.vulnerability_scanner.analyze_open_ports(
                    open_ports, host_ip
                )
                
                scan_results.append(vulnerability_analysis)
                
                # 위험도가 낮아지면 의심 목록에서 제거
                if vulnerability_analysis['overall_risk'] in ['low', 'medium']:
                    hosts_to_remove.add(host_ip)
                    logger.info(f"{host_ip}: 위험도 감소 - 의심 목록에서 제거")
            
            # 의심 목록 업데이트
            self.suspicious_hosts -= hosts_to_remove
            
            # 스캔 결과 저장
            if scan_results:
                scan_summary = {
                    'scan_type': 'quick_scan',
                    'scan_time': scan_start_time.isoformat(),
                    'duration_seconds': (datetime.now() - scan_start_time).total_seconds(),
                    'hosts_scanned': len(scan_results),
                    'results': scan_results
                }
                
                self._save_scan_results(scan_summary)
            
            self.stats['last_quick_scan'] = scan_start_time.isoformat()
            
            logger.info(f"=== 빠른 스캔 완료: {len(scan_results)}개 호스트 분석 ===")
            
        except Exception as e:
            logger.error(f"빠른 스캔 중 오류: {e}")
    
    def _save_scan_results(self, scan_summary: Dict):
        """스캔 결과 저장"""
        try:
            # 타임스탬프로 파일명 생성
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            scan_type = scan_summary['scan_type']
            filename = f"{scan_type}_{timestamp}.json"
            filepath = os.path.join(self.output_dir, filename)
            
            # JSON 파일로 저장
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(scan_summary, f, ensure_ascii=False, indent=2)
            
            logger.info(f"스캔 결과 저장: {filepath}")
            
            # 이력에 추가
            self.scan_history.append({
                'timestamp': scan_summary['scan_time'],
                'type': scan_type,
                'file': filename
            })
            
            # 이력 크기 제한 (최근 100개만 유지)
            if len(self.scan_history) > 100:
                self.scan_history = self.scan_history[-100:]
            
        except Exception as e:
            logger.error(f"스캔 결과 저장 오류: {e}")
    
    def get_statistics(self) -> Dict:
        """스캐너 통계 반환"""
        return {
            **self.stats,
            'suspicious_hosts': len(self.suspicious_hosts),
            'running': self.running,
            'scan_history_count': len(self.scan_history)
        }
    
    def get_suspicious_hosts(self) -> List[str]:
        """의심 호스트 목록 반환"""
        return list(self.suspicious_hosts)
    
    def add_suspicious_host(self, ip_address: str):
        """의심 호스트 수동 추가"""
        self.suspicious_hosts.add(ip_address)
        logger.info(f"의심 호스트 추가: {ip_address}")
    
    def remove_suspicious_host(self, ip_address: str):
        """의심 호스트 제거"""
        if ip_address in self.suspicious_hosts:
            self.suspicious_hosts.remove(ip_address)
            logger.info(f"의심 호스트 제거: {ip_address}")


# 전역 싱글톤 인스턴스
_global_scanner = None


def get_auto_scanner(network_range: str = "192.168.0.0/24") -> VulnerabilityAutoScanner:
    """
    전역 자동 스캐너 인스턴스 반환 (싱글톤 패턴)
    
    Args:
        network_range: 스캔할 네트워크 범위
    
    Returns:
        VulnerabilityAutoScanner 인스턴스
    """
    global _global_scanner
    if _global_scanner is None:
        _global_scanner = VulnerabilityAutoScanner(network_range=network_range)
    return _global_scanner

